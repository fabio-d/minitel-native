.program mememu_out
; This program sets the output value of the 8 AD pins, but not the direction,
; which is controlled by `mememu_dir` program below.
.out 8

; Run at full speed.
.clock_div 1

; The value to be emitted is taken from the FIFO in random-access mode.
.fifo txget

PUBLIC entry_point:
; Infinite loop that reads from the FIFO and sets the pins' output value.
.wrap_target
mov osr, rxfifo[0]
out pins, 8
.wrap

; ------------------------------------------------------------------------------

.program mememu_dir
; This program sets the direction of the AD pins, but not the value, which is
; controlled by `mememu_out` program above. It keeps the 4 sideset pins
; configured as outputs for as long as the PSEN line is low.
; It is meant to be instantiated twice, with 4 out of the 8 AD pins handled
; separately by each instance.
.side_set 4 opt pindirs

; Run at full speed.
.clock_div 1

PUBLIC entry_point:
.wrap_target
; Configure the pins as inputs and wait for PSEN to become low.
wait 0 jmppin       side 0b0000

; Wait for the bus to be released by the Minitel's CPU.
nop
nop
nop
nop
nop
nop
nop
nop

; Configure the pins as outputs and wait for PSEN to become high again.
wait 1 jmppin       side 0b1111
.wrap

; ------------------------------------------------------------------------------

.program mememu_latch
; This program "latches" the address according to ALE and emits it to the FIFO
; on the falling edge. The emitted address is prefixed with a constant value, to
; form a pointer for DMA chaining.
;
; This program is instantiated with jmppin = ALE.
.in 16 left auto 32

; Run at full speed.
.clock_div 1

PUBLIC entry_point:
; Store the prefix into OSR (which, from now on, will stay constant).
pull

; Initially just wait in a loop for C++ to move the PC to the "active" label.
; Note that C++ code can jump back to this label at any time.
PUBLIC paused:
jmp paused

; C++ code can force jumping to this label at any time. Let's be sure to start
; from a clean state and reset the ISR shift counter to 0.
PUBLIC active:
mov isr, null

; First phase: wait for address 0x0000 to be fetched.
; During this phase any address other than 0x0000 is ignored.
in osr, 16
wait_zero_loop:
wait 1 jmppin
ale_is_high_loop1:
mov x, y
mov y, pins
jmp pin ale_is_high_loop1
jmp x-- wait_zero_loop    ; keep waiting if x != 0
in null, 16

; Second phase (operational): all addresses are accepted.
; The timing of this loop intentionally matches the one in the previous phase,
; to minimize the chances of hard-to-reproduce issues due to differences.
.wrap_target
in osr, 16
wait 1 jmppin
ale_is_high_loop2:
mov x, y
mov y, pins
jmp pin ale_is_high_loop2
nop
in x, 16
.wrap
